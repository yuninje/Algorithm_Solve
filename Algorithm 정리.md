### Greedy Algorithm
    : 선택의 기로에서 최적이라 생각되는것을 선택
- **최적** 을 어떻게?
- **Greedy choice property** : 앞의 선택이 이후 선택에 영향을 주지 않는다.
- **Optimal substructure** : 문제 전체에 대한 최적해가 부분 문제에 대해서도 최적해가 된다.

- ex) 분할가능 배낭문제


### DP (Dynamic Programming) 
    : 모든 경우의 수를 확인하지만 중간계산 결과를 저장하여 다시 사용하는 방식으로 계산량 감소를 유도.
- ex ) 0-1 Knapsack Problem
- 방법
  - 완전 탐색 알고리즘 방법 생각합니다.
  - 최적 부분 문제를 구할 수 있는지 부분 문제 정의를 생각합니다.
  - 최대한 문제가 중복이 될 수 있도록 재귀 호출 입력 이전에 꼭 필요한 정보만 넘깁니다.
  - 입력이 배열이나 문자열인경우 적절하게 부분 문제를 만들 수 있도록 합니다. (위에서 처럼 배열의 부분을 인덱스를 활용하여 넘기도록 합시다!)
  - 메모이제이션을 이용합니다.


#### LCS (Longest common substring)
    : 최장 공통 부분 수열

